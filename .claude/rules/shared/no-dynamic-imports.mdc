---
alwaysApply: true
---
# No Dynamic Imports Policy

**CRITICAL RULE**: This codebase NEVER uses dynamic imports (`import()`) **except** in Vue Router route definitions for lazy-loaded views.

## Why No Dynamic Imports?

- **Build Reliability**: Static imports ensure all dependencies are resolved at build time
- **Type Safety**: Dynamic imports can bypass TypeScript's module resolution
- **Performance Predictability**: All code is bundled and optimized together
- **Debugging**: Stack traces and source maps work correctly with static imports
- **Tree Shaking**: Vite can properly analyze and optimize static import graphs

## What to Use Instead

### ❌ NEVER Do This

- Calling `import()` anywhere except Vue Router route definitions
- Conditional/branch-based module loading
- Any runtime module resolution that changes bundling behavior

### ✅ Always Do This

```typescript
// Static imports at the top of the file
import { myFunction } from './some-module'
import MyComponent from '@/components/MyComponent.vue'
```

## Exceptions

The **ONLY** acceptable use of dynamic imports is in **Vue Router route definitions**, where Vue Router's lazy-loading mechanism handles them properly:

```typescript
// router.ts - This is acceptable
const routes: RouteRecordRaw[] = [
  {
    path: '/transactions',
    component: () => import('@/views/TransactionsView.vue')
  }
]
```

## Code Review Checklist

- [ ] No `import()` calls outside of router definitions
- [ ] All module imports are static and at the top of files
- [ ] Conditional logic doesn't affect imports
